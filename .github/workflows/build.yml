name: Build and Release

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]
  schedule:
    # Run monthly on the 1st at 2 AM UTC
    - cron: '0 2 1 * *'
  workflow_dispatch:

env:
  GO_VERSION: '1.22'
  WAILS_VERSION: 'v2.10.2'
  
jobs:
  check-changes:
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.changes.outputs.should_build }}
      version: ${{ steps.version.outputs.version }}
      is_release: ${{ steps.version.outputs.is_release }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Check for changes since last release
        id: changes
        run: |
          # For scheduled builds, check if there are changes since last release
          if [ "${{ github.event_name }}" = "schedule" ]; then
            LAST_RELEASE=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            if [ -z "$LAST_RELEASE" ]; then
              echo "No previous release found, proceeding with build"
              echo "should_build=true" >> $GITHUB_OUTPUT
            else
              CHANGES=$(git rev-list $LAST_RELEASE..HEAD --count)
              if [ "$CHANGES" -gt 0 ]; then
                echo "Found $CHANGES changes since last release, proceeding with build"
                echo "should_build=true" >> $GITHUB_OUTPUT
              else
                echo "No changes since last release, skipping build"
                echo "should_build=false" >> $GITHUB_OUTPUT
              fi
            fi
          else
            # For push/PR events, always build
            echo "should_build=true" >> $GITHUB_OUTPUT
          fi
          
      - name: Generate version
        id: version
        run: |
          if [[ $GITHUB_REF == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
            echo "is_release=true" >> $GITHUB_OUTPUT
          else
            # Generate version based on commit hash and date for non-release builds
            VERSION="v$(date +'%Y.%m.%d')-${GITHUB_SHA:0:7}"
            echo "is_release=false" >> $GITHUB_OUTPUT
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Generated version: $VERSION"

  build:
    needs: check-changes
    if: needs.check-changes.outputs.should_build == 'true'
    strategy:
      matrix:
        include:
          - os: windows-latest
            platform: windows
            arch: amd64
            extension: .exe
          - os: macos-latest
            platform: darwin
            arch: amd64
          - os: macos-latest
            platform: darwin
            arch: arm64
          - os: ubuntu-latest
            platform: linux
            arch: amd64
    runs-on: ${{ matrix.os }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          
      - name: Install dependencies (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          # Install system dependencies
          sudo apt-get update
          sudo apt-get install -y build-essential pkg-config
          
          # Try to install libwebkit2gtk-4.1-dev first, then fall back to 4.0-dev
          if sudo apt-get install -y libwebkit2gtk-4.1-dev; then
            echo "Installed webkit2gtk-4.1-dev"
            # Create symlink for 4.0 compatibility if needed
            if [ ! -f /usr/lib/pkgconfig/webkit2gtk-4.0.pc ] && [ -f /usr/lib/pkgconfig/webkit2gtk-4.1.pc ]; then
              sudo ln -sf /usr/lib/pkgconfig/webkit2gtk-4.1.pc /usr/lib/pkgconfig/webkit2gtk-4.0.pc
            fi
            # Also check x86_64 path
            if [ ! -f /usr/lib/x86_64-linux-gnu/pkgconfig/webkit2gtk-4.0.pc ] && [ -f /usr/lib/x86_64-linux-gnu/pkgconfig/webkit2gtk-4.1.pc ]; then
              sudo ln -sf /usr/lib/x86_64-linux-gnu/pkgconfig/webkit2gtk-4.1.pc /usr/lib/x86_64-linux-gnu/pkgconfig/webkit2gtk-4.0.pc
            fi
          elif sudo apt-get install -y libwebkit2gtk-4.0-dev; then
            echo "Installed webkit2gtk-4.0-dev"
          else
            echo "ERROR: Failed to install either libwebkit2gtk-4.1-dev or libwebkit2gtk-4.0-dev" >&2
            exit 1
          fi
          
          go install github.com/wailsapp/wails/v2/cmd/wails@${{ env.WAILS_VERSION }}
          
      - name: Install Wails (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          go install github.com/wailsapp/wails/v2/cmd/wails@${{ env.WAILS_VERSION }}
          
      - name: Install Wails (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          go install github.com/wailsapp/wails/v2/cmd/wails@${{ env.WAILS_VERSION }}
          
      - name: Build application
        env:
          CGO_ENABLED: 1
        run: |
          if [ "${{ matrix.platform }}" = "darwin" ] && [ "${{ matrix.arch }}" = "arm64" ]; then
            export GOARCH=arm64
            export CGO_ENABLED=1
          fi
          wails build -platform ${{ matrix.platform }}/${{ matrix.arch }} -clean
        shell: bash
        
      - name: Prepare artifacts
        run: |
          mkdir -p dist
          
          # Find the built binary (Wails may place it in different locations)
          if [ "${{ matrix.os }}" = "windows-latest" ]; then
            BINARY_NAME="dockerizathinginator.exe"
            OUTPUT_NAME="dockerizathinginator-${{ matrix.platform }}-${{ matrix.arch }}${{ matrix.extension }}"
          else
            BINARY_NAME="dockerizathinginator"
            OUTPUT_NAME="dockerizathinginator-${{ matrix.platform }}-${{ matrix.arch }}"
          fi
          
          # Look for the binary in common Wails output locations
          BINARY_PATH=""
          if [ "${{ matrix.platform }}" = "darwin" ]; then
            # On macOS, Wails creates an app bundle
            if [ -f "build/bin/$BINARY_NAME.app/Contents/MacOS/$BINARY_NAME" ]; then
              BINARY_PATH="build/bin/$BINARY_NAME.app/Contents/MacOS/$BINARY_NAME"
              echo "Found macOS app binary at: $BINARY_PATH"
            fi
          else
            # On Linux/Windows, look for regular binary
            for path in "build/bin/$BINARY_NAME" "build/$BINARY_NAME" "./$BINARY_NAME"; do
              if [ -f "$path" ]; then
                BINARY_PATH="$path"
                echo "Found binary at: $BINARY_PATH"
                break
              fi
            done
          fi
          
          if [ -z "$BINARY_PATH" ]; then
            echo "ERROR: Could not find built binary"
            echo "Contents of build directory:"
            find build -type f 2>/dev/null || echo "No build directory found"
            echo "Contents of current directory:"
            ls -la
            exit 1
          fi
          
          # Copy binary to dist
          cp "$BINARY_PATH" "dist/$OUTPUT_NAME"
          
          # Copy Ansible playbooks
          cp -r ansible dist/
          
          # Create archive
          if [ "${{ matrix.os }}" = "windows-latest" ]; then
            7z a "dist/dockerizathinginator-${{ matrix.platform }}-${{ matrix.arch }}.zip" "dist/$OUTPUT_NAME" dist/ansible
          else
            tar -czf "dist/dockerizathinginator-${{ matrix.platform }}-${{ matrix.arch }}.tar.gz" -C dist "$OUTPUT_NAME" ansible
          fi
        shell: bash
        
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dockerizathinginator-${{ matrix.platform }}-${{ matrix.arch }}
          path: |
            dist/dockerizathinginator-${{ matrix.platform }}-${{ matrix.arch }}*
            dist/ansible/
          retention-days: 90

  release:
    needs: [check-changes, build]
    if: needs.check-changes.outputs.is_release == 'true' && needs.check-changes.outputs.should_build == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          
      - name: Prepare release assets
        run: |
          mkdir -p release-assets
          find artifacts -name "*.tar.gz" -o -name "*.zip" | while read file; do
            cp "$file" release-assets/
          done
          ls -la release-assets/
          
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.check-changes.outputs.version }}
          name: Release ${{ needs.check-changes.outputs.version }}
          draft: false
          prerelease: false
          files: release-assets/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  package-upload:
    needs: [check-changes, build]
    if: needs.check-changes.outputs.should_build == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          
      - name: Upload to GitHub Packages
        run: |
          echo "Uploading packages with version: ${{ needs.check-changes.outputs.version }}"
          # Note: This would typically use docker/build-push-action or similar
          # for actual package registry uploads. For now, artifacts are stored as build artifacts.
          find artifacts -type f -name "*.tar.gz" -o -name "*.zip" | while read file; do
            echo "Would upload: $file"
          done